package genutil

import (
	"bytes"
	"path/filepath"

	"github.com/mkideal/log"

	"github.com/midlang/mid/src/mid/build"
)

// Context holds current context for generating codes of specified package
type Context struct {
	// Pkg represents current package
	Pkg *build.Package
	// Root represents root template
	Root *Template
	// Plugin represents current plugin
	Plugin build.Plugin
	// Config represents current plugin runtime config
	Config build.PluginRuntimeConfig
	// Kind holds current template kind
	Kind string
	// Suffix holds current template suffix
	Suffix string
	// Pwd holds current template file directory
	Pwd string

	// BuildType functions for current language
	buildType BuildTypeFunc
	// beans holds all beans in current package
	beans map[string]*build.Bean
}

// NewContext creates a context by buildType,plugin,plugin_config
func NewContext(
	buildType BuildTypeFunc,
	plugin build.Plugin,
	config build.PluginRuntimeConfig,
) *Context {
	ctx := &Context{
		buildType: buildType,
		Plugin:    plugin,
		Config:    config,
		beans:     make(map[string]*build.Bean),
	}
	return ctx
}

func (ctx *Context) initWithPkg(pkg *build.Package) {
	ctx.Pkg = pkg
	ctx.beans = make(map[string]*build.Bean)
	for _, file := range ctx.Pkg.Files {
		for _, bean := range file.Beans {
			ctx.beans[bean.Name] = bean
		}
	}
}

// BuildType executes buildType function
func (ctx *Context) BuildType(typ build.Type) string {
	return ctx.buildType(typ)
}

// Getenv gets custom envvar
func (ctx *Context) Getenv(key string) string {
	if ctx.Config.Envvars == nil {
		return ""
	}
	return ctx.Config.Envvars[key]
}

// FindBean finds bean by name in current package
func (ctx *Context) FindBean(name string) *build.Bean {
	return ctx.beans[name]
}

// AutoGenDeclaration returns a declaration which would be written to each generated file header
// e.g.
// // AUTO-GENERATED by midc!! DON'T EDIT!!
//
func (ctx *Context) AutoGenDeclaration() string {
	if value := ctx.Config.Getenv(ctx.Plugin.Lang + ":autogen_decl"); value != "" {
		return value
	}
	return ctx.Config.Getenv("autogen_decl")
}

// Extension inserts code for extensions at specific position
func (ctx *Context) Extension(at string, data interface{}) (string, error) {
	var buf bytes.Buffer
	for _, ext := range ctx.Config.Extensions {
		extdir := filepath.Join(ctx.Config.ExtentionsDir, ext.Path, "templates")
		values := ext.Find(ctx.Plugin.Lang, ctx.Kind, at)
		log.WithJSON(log.M{
			"extdir": extdir,
			"lang":   ctx.Plugin.Lang,
			"kind":   ctx.Kind,
			"at":     at,
		}).Debug("values.length: %d", len(values))
		for _, value := range values {
			if !value.IsValid() {
				log.WithJSON(log.M{
					"lang": ctx.Plugin.Lang,
					"kind": ctx.Kind,
					"at":   at,
				}).Warn("value %v is invalid", value)
				continue
			}
			if value.Suffix != "" && value.Suffix != ctx.Suffix {
				continue
			}
			if buf.Len() > 0 {
				buf.WriteByte('\n')
			}
			if value.Text != "" {
				buf.WriteString(value.Text)
				continue
			}
			filename := value.Template
			if !filepath.IsAbs(filename) {
				filename = filepath.Join(extdir, filename)
			}
			// NOTE: meta header would be ignored
			_, temp, err := ParseTemplateFile(filename)
			if err != nil {
				return "", err
			}
			pwd := context.Pwd
			ctx.Pwd, _ = filepath.Split(filename)
			err = temp.Execute(&buf, data)
			context.Pwd = pwd
			if err != nil {
				return "", err
			}
		}
	}
	return buf.String(), nil
}

// JSInitValue returns init value of javascript by Type
func (ctx *Context) JSInitValue(typ build.Type) string {
	switch {
	case typ.IsInt():
		return "0"
	case typ.IsBool():
		return "false"
	case typ.IsString():
		return `""`
	case typ.IsArray():
		t, ok := typ.(*build.ArrayType)
		if ok {
			size, ok := build.IntFromExpr(t.Size)
			if ok {
				return "new Array(" + size + ")"
			}
		}
	case typ.IsVector():
		return "new Array()"
	case typ.IsMap():
		return "new Map()"
	case typ.IsStruct():
		t, ok := typ.(*build.StructType)
		if ok {
			return "new " + t.String(".") + "()"
		}
	}
	return "null"
}
